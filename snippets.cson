'.source.cpp':
    'IO-Optimization':
        'prefix': 'iooptim'
        'body': """
        #define _CRT_DISABLE_PERFCRIT_LOCKS
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
        """

    'std::set':
        'prefix': 'set'
        'body': 'std::set<${1:int}> $2'

    'std::unordered_set':
        'prefix': 'unordered_set'
        'body': 'std::unordered_set<${1:int}> $2'

    'std::vector':
        'prefix': 'vector'
        'body': 'std::vector<${1:int}> $2'

    'std::queue':
        'prefix': 'queue'
        'body': 'std::queue<${1:int}> $2'

    'std::priority_queue':
        'prefix': 'priority_queue'
        'body': 'std::priority_queue<${2:int}${1:, std::vector<${2:int}>, std::greater<${2:int}> }> ${3:/*ascending*/}'

    'std::deque':
        'prefix': 'deque'
        'body': 'std::deque<${1:int}> $2'

    'std::stack':
        'prefix': 'stack'
        'body': 'std::stack<${1:int}> $2'

    'std::bitset':
        'prefix': 'bitset'
        'body': 'std::bitset<${1:SIZE}> $2'

    'std::map':
        'prefix': 'map'
        'body': 'std::map<${1:int}, ${2:int}> $3'

    'std::unordered_map':
        'prefix': 'unordered_map'
        'body': 'std::unordered_map<${1:int}, ${2:int}> $3'

    'std::pair':
        'prefix': 'pair'
        'body': 'std::pair<${1:int}, ${2:int}> $3'

    'Read array':
        'prefix': 'readarr'
        'body': """
        int ${1:n};
        std::cin >> ${1:n};
        std::vector<${3:int}> ${2:a}(${1:n});
        for (auto& x : ${2:a}) std::cin >> x;$4
        """

    'Read graph':
        'prefix': 'readgra'
        'body': """
        int n, m;
        std::cin >> n >> m;
        std::vector<std::vector<int> > gra(n);
        for (int i = 0; i < m; i++) {
            int u, v;
            std::cin >> u >> v;
            u--; v--;
            gra[u].push_back(v);
            ${1:gra[v].push_back(u);}
        }
        """

    'DFS':
        'prefix': 'dfs'
        'body': """
        void dfs(std::vector<std::vector<int> >& gra, std::vector<char>& used, int u) {
            ${1:used[u] = true;
            for (int v : gra[u]) {
                if (used[v]) continue;
                dfs(gra, used, v);
            \\}}
        }
        """

    'BFS':
        'prefix': 'bfs'
        'body': """
        void bfs(std::vector<std::vector<int> >& gra, std::vector<char>& used, int s) {
            ${1:std::queue<int> q;
            q.push(s);
            used[s] = true;
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                used[u] = true;
                for (int v : gra[u]) {
                    if (used[v]) continue;
                    q.push(v);
                \\}
            \\}}
        }
        """

    'New contest file':
        'prefix': 'cf'
        'body': """
        #include <bits/stdc++.h>

        using namespace std;
        ${1:
        void solve() {
            $2
        \\}
        }
        int main(int argc, char const *argv[]) {
            ${1:int t;
            std::cin >> t;
            while (t--) solve();}$3
        }
        """

    'Brute force':
        'prefix': 'brute'
        'body': """
        for (size_t bf = 0; bf < (1 << ${1:vars_cnt}); bf++) {
            bitset<${2:MAX_CNT}> bs(bf);
            for (size_t i = 0; i < ${1:VARS_CNT}; i++) {
                ${3:bs[i]}
            }
        }
        """

    'std::sort':
        'prefix': 'sort'
        'body': 'sort(${2:v}.begin(), ${2:v}.end()${1:, [&](const ${3:T}& lhs, const ${3:T}& rhs) {$4\\}});$5'

    'unsigned long long':
        'prefix': 'ull'
        'body': 'unsigned long long'

    'define ull':
        'prefix': 'useull'
        'body': 'using ull = unsigned long long;'

    'For Loop':
        'prefix': 'for'
        'body': """
        for (int ${1:i} = ${3:0}; ${1:i} < ${2:n}; ${1:i}${4:++}) {
            $5
        }
        """

    'Ranged For Loop':
        'prefix': 'forange'
        'body': """
        for (auto& ${2:x} : ${1:v}) {
            $3
        }
        """

    'Binary Power':
        'prefix': 'binpow'
        'body': """
        int binpow(int a, int n) {
        	int res = 1;
        	while (n) {
        		if (n&1) res *= a;
        		a *= a;
        		n >>= 1;
        	}
        	return res;
        }
        """

    'Modular Binary Power':
        'prefix': 'modbinpow'
        'body': """
        int modbinpow(int a, int n, int mod) {
        	int res = 1;
        	while (n) {
        		if (n&1) res = (res *1ull* a) % mod;
        		a = (a *1ull* a) % mod;
        		n >>= 1;
        	}
        	return res;
        }
        """

    'Upper Bound':
        'prefix': 'upper_bound'
        'body': 'upper_bound(${1:v}.begin(), ${1:v}.end(), ${2:el})$3'

    'Lower Bound':
        'prefix': 'lower_bound'
        'body': 'lower_bound(${1:v}.begin(), ${1:v}.end(), ${2:el})$3'

    'Disjoint Set Union':
        'prefix': 'dsu'
        'body': """
        struct DSU {
            std::vector<int> parent, rank;
            DSU(int n)
            : parent(std::vector<int>(n)), rank(std::vector<int>(n, 0)) {
                iota(parent.begin(), parent.end(), 0);
            }
            int find(int v) {
            	if (v == parent[v]) return v;
            	return parent[v] = find(parent[v]);
            }
            void join(int a, int b) {
            	a = find(a);
            	b = find(b);
            	if (a != b) {
            		if (rank[a] < rank[b]) swap(a, b);
            		parent[b] = a;
            		if (rank[a] == rank[b]) ++rank[a];
            	}
            }
        };
        """

    'Factorial Precalc':
        'prefix': 'precfact'
        'body': """
        const int MAXN = ${1:200000};
        int fact[MAXN+1];
        int inv_fact[MAXN+1];
        void precalc() {
            fact[0] = 1;
            for (int i = 1; i <= MAXN; i++)
                fact[i] = (fact[i-1] *1ull* i) % MOD;
            inv_fact[MAXN] = modinv(fact[MAXN], MOD);
            for (int i = MAXN-1; i >= 0; i--)
                inv_fact[i] = (inv_fact[i+1] *1ull* (i+1)) % MOD;
        }$2
        """

    'Modular Inverse':
        'prefix': 'modinv'
        'body': """
        int modinv(int a, int mod) {
            return modbinpow(a, mod - 2, mod);
        }
        """
